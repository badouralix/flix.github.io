<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Flix Standard Library: Map</title>
    <link href="__app__.css" rel="stylesheet" type="text/css"/>
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>

<!-- Application Element -->
<div id="app">
  <div id="navbar"></div>
</div>

<!-- Menu Data -->
<script type="application/ecmascript">
window.menu = [{
  "name":"Prelude",
  "link":"index.html"
},{
  "name":"Int64",
  "link":"Int64.html"
},{
  "name":"Int8",
  "link":"Int8.html"
},{
  "name":"Set",
  "link":"Set.html"
},{
  "name":"Result",
  "link":"Result.html"
},{
  "name":"Float32",
  "link":"Float32.html"
},{
  "name":"Map",
  "link":"Map.html"
},{
  "name":"Float64",
  "link":"Float64.html"
},{
  "name":"Int32",
  "link":"Int32.html"
},{
  "name":"BigInt",
  "link":"BigInt.html"
},{
  "name":"Char",
  "link":"Char.html"
},{
  "name":"Int16",
  "link":"Int16.html"
},{
  "name":"List",
  "link":"List.html"
},{
  "name":"Option",
  "link":"Option.html"
}];
</script>

<!-- Page Data -->
<script type="application/ecmascript">
window.page = {
  "namespace":"Map",
  "types":[],
  "definitions":[{
    "name":"foldWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> b -> v -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"b",
    "comment":"  Alias for `foldLeftWithKey`. "
  },{
    "name":"reduceRight",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> v -> v"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[v]",
    "comment":"  Applies `f` to all values in `m` going from right to left until a single value `v` is obtained.  Returns `Some(v)`.  That is, the result is of the form: `Some(f(v1, ...f(vn-2, f(vn-1, vn))...))`  Returns `None` if `m` is the empty map. "
  },{
    "name":"insertWith",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> v -> v"
    },{
      "name":"k",
      "tpe":"k"
    },{
      "name":"v",
      "tpe":"v"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Updates `m` with `k -> f(v, v1)` if `k -> v1` is in `m`.  Otherwise, updates `m` with `k -> v`. "
  },{
    "name":"differenceWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> v -> Option[v]"
    },{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the difference of `m1` and `m2`, i.e. `m1 - m2`.  When a key `k` is in both `m1` and `m2`, `k` and the associated values are passed to the merge function `f`.  If `f` returns `None` the mapping with `k` is thrown away (proper set difference).  If `f` returns `Some(v)` the mapping `k -> v` is included in the result. "
  },{
    "name":"intersectionWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> v -> v"
    },{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the intersection of `m1` and `m2` where key collisions are resolved with the merge function `f`, taking both the key and values. "
  },{
    "name":"differenceWith",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> v -> Option[v]"
    },{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the difference of `m1` and `m2`, i.e. `m1 - m2`.  When a key `k` is in both `m1` and `m2`, the associated values are passed to the merge function `f`.  If `f` returns `None` the mapping with `k` is thrown away (proper set difference).  If `f` returns `Some(v)` the mapping `k -> v` is included in the result. "
  },{
    "name":"singleton",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"k",
      "tpe":"k"
    },{
      "name":"v",
      "tpe":"v"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the singleton map where key `k` is mapped to value `v`.  `@{k -> v}` is syntactic sugar for `singleton` (`@{k -> v} = singleton(k, v)`). "
  },{
    "name":"intersection",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the left-biased intersection of `m1` and `m2`.  That is, key collisions are resolved by taking the mapping from `m1`. "
  },{
    "name":"reduceWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> k -> v -> (k, v)"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[(k, v)]",
    "comment":"  Alias for `reduceLeftWithKey`. "
  },{
    "name":"keysOf",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Set[k]",
    "comment":"  Returns the keys of `m`. "
  },{
    "name":"difference",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the difference of `m1` and `m2`, i.e. `m1 - m2`.  That is, returns the map `m1` with the keys removed that are in `m2`. "
  },{
    "name":"foldLeftWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> b -> v -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"b",
    "comment":"  Applies `f` to a start value `s` and all key-value pairs in `m` going from left to right.  That is, the result is of the form: `f(...f(k2, f(k1, s, v1), v2)..., vn)`. "
  },{
    "name":"delete",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"k",
      "tpe":"k"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  "
  },{
    "name":"foldLeft",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"b -> v -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"b",
    "comment":"  Applies `f` to a start value `s` and all values in `m` going from left to right.  That is, the result is of the form: `f(...f(f(s, v1), v2)..., vn)`. "
  },{
    "name":"isEmpty",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if `m` is the empty map, i.e. `Map(Nil)`. "
  },{
    "name":"foldRightWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> b -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"b",
    "comment":"  Applies `f` to a start value `s` and all key-value pairs in `m` going from right to left.  That is, the result is of the form: `f(k1, v1, ...f(kn-1, vn-1, f(kn, vn, s)))`. "
  },{
    "name":"count",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> Bool"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Int32",
    "comment":"  Returns the number of mappings in `m` that satisfy the predicate `f`. "
  },{
    "name":"filterWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> Bool"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns a map of all mappings `k -> v` in `m` where `(k, v)` satisfies the predicate `f`. "
  },{
    "name":"reduceRightWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> k -> v -> (k, v)"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[(k, v)]",
    "comment":"  Applies `f` to all mappings in `m` going from right to left until a single mapping `(k, v)` is obtained.  Returns `Some((k, v))`.  That is, the result is of the form: `Some(f(k1, v1, ...f(kn-2, vn-2, f(kn-1, vn-1, kn, vn))...))`  Returns `None` if `m` is the empty map. "
  },{
    "name":"eq",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if `m1` and `m2` and equal, i.e. they have the same mappings. "
  },{
    "name":"findRight",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> Bool"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[(k, v)]",
    "comment":"  Optionally returns the first mapping of `m` that satisfies the predicate `f` when searching from right to left. "
  },{
    "name":"empty",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[],
    "result":"Map['5744, '5745]",
    "comment":"  Returns the empty map.  `@{}` is syntactic sugar for `empty` (`@{} = empty()`). "
  },{
    "name":"forall",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> Bool"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if all mappings in `m` satisfy the predicate `f`.  Returns `true` if `m` is the empty map. "
  },{
    "name":"insert",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"k",
      "tpe":"k"
    },{
      "name":"v",
      "tpe":"v"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Updates `m` with `k -> v`. "
  },{
    "name":"memberOf",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"k",
      "tpe":"k"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if `m` contains the key `k`. "
  },{
    "name":"foldRight",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> b -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"b",
    "comment":"  Applies `f` to a start value `s` and all values in `m` going from right to left.  That is, the result is of the form: `f(v1, ...f(vn-1, f(vn, s)))`. "
  },{
    "name":"toList",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"List[(k, v)]",
    "comment":"  Returns the map `m` as a list of key-value pairs. "
  },{
    "name":"toSet",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Set[(k, v)]",
    "comment":"  Returns the map `m` as a set of key-value pairs. "
  },{
    "name":"updateWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> Option[v]"
    },{
      "name":"k",
      "tpe":"k"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Updates `m` with `k -> v1` if `k -> v` is in `m` and `f(k, v) = Some(v1).  Otherwise, returns `m`. "
  },{
    "name":"adjust",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> v"
    },{
      "name":"k",
      "tpe":"k"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Updates `m` with `k -> f(v)` if `k -> v` is in `m`.  Otherwise, returns `m`. "
  },{
    "name":"isSubmapOf",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if all mappings in `m1` occur in `m2`. "
  },{
    "name":"valuesOf",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"List[v]",
    "comment":"  Returns the values of `m`. "
  },{
    "name":"getWithDefault",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"k",
      "tpe":"k"
    },{
      "name":"d",
      "tpe":"v"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"v",
    "comment":"  Returns `v` if `k -> v` is in `m`.  Otherwise, returns `d`. "
  },{
    "name":"isProperSubmapOf",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if all mappings in `m1` occur in `m2` and `m1 != m2`. "
  },{
    "name":"mapWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v1"
    },{
      "name":"v2"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v1 -> v2"
    },{
      "name":"m",
      "tpe":"Map[k, v1]"
    }],
    "result":"Map[k, v2]",
    "comment":"  Returns a map with mappings `k -> f(k, v)` for every `k -> v` in `m`. "
  },{
    "name":"map",
    "tparams":[{
      "name":"k"
    },{
      "name":"v1"
    },{
      "name":"v2"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v1 -> v2"
    },{
      "name":"m",
      "tpe":"Map[k, v1]"
    }],
    "result":"Map[k, v2]",
    "comment":"  Returns a map with mappings `k -> f(v)` for every `k -> v` in `m`. "
  },{
    "name":"unionWith",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> v -> v"
    },{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the union of `m1` and `m2` where key collisions are resolved with the merge function `f`. "
  },{
    "name":"adjustWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> v"
    },{
      "name":"k",
      "tpe":"k"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Updates `m` with `k -> f(k, v)` if `k -> v` is in `m`.  Otherwise, returns `m`. "
  },{
    "name":"find",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> Bool"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[(k, v)]",
    "comment":"  Alias for `findLeft`. "
  },{
    "name":"intersectionWith",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> v -> v"
    },{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the intersection of `m1` and `m2` where key collisions are resolved with the merge function `f`. "
  },{
    "name":"findLeft",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> Bool"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[(k, v)]",
    "comment":"  Optionally returns the first mapping of `m` that satisfies the predicate `f` when searching from left to right. "
  },{
    "name":"size",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Int32",
    "comment":"  Returns the size of `m`. "
  },{
    "name":"reduceLeft",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> v -> v"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[v]",
    "comment":"  Applies `f` to all values in `m` going from left to right until a single value `v` is obtained.  Returns `Some(v)`.  That is, the result is of the form: `Some(f(...f(f(v1, v2), v3)..., vn))`  Returns `None` if `m` is the empty map. "
  },{
    "name":"reduce",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> v -> v"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[v]",
    "comment":"  Alias for `reduceLeft`. "
  },{
    "name":"update",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> Option[v]"
    },{
      "name":"k",
      "tpe":"k"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Updates `m` with `k -> v1` if `k -> v` is in `m` and `f(v) = Some(v1).  Otherwise, returns `m`. "
  },{
    "name":"exists",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> Bool"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if at least one mapping in `m` satisfies the predicate `f`.  Returns `false` if `m` is the empty map. "
  },{
    "name":"fold",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"b -> v -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"b",
    "comment":"  Alias for `foldLeft`. "
  },{
    "name":"filter",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"v -> Bool"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns a map of all mappings `k -> v` in `m` where `v` satisfies the predicate `f`. "
  },{
    "name":"unionWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> v -> v"
    },{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the union of `m1` and `m2` where key collisions are resolved with the merge function `f`, taking both the key and values. "
  },{
    "name":"get",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"k",
      "tpe":"k"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[v]",
    "comment":"  Returns `Some(v)` if `k -> v` is in `m`.  Otherwise returns `None`. "
  },{
    "name":"union",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"m1",
      "tpe":"Map[k, v]"
    },{
      "name":"m2",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Returns the left-biased union of `m1` and `m2`.  That is, key collisions are resolved by taking the mapping from `m1`. "
  },{
    "name":"insertWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> v -> v"
    },{
      "name":"k",
      "tpe":"k"
    },{
      "name":"v",
      "tpe":"v"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Map[k, v]",
    "comment":"  Updates `m` with `k -> f(k, v, v1)` if `k -> v1` is in `m`.  Otherwise, updates `m` with `k -> v`. "
  },{
    "name":"reduceLeftWithKey",
    "tparams":[{
      "name":"k"
    },{
      "name":"v"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"k -> v -> k -> v -> (k, v)"
    },{
      "name":"m",
      "tpe":"Map[k, v]"
    }],
    "result":"Option[(k, v)]",
    "comment":"  Applies `f` to all mappings in `m` going from left to right until a single mapping `(k, v)` is obtained.  Returns `Some((k, v))`.  That is, the result is of the form: `Some(f(...f(f(k1, v1, k2, v2), k3, v3)..., kn, vn))`  Returns `None` if `m` is the empty map. "
  }],
  "laws":[],
  "tests":[],
  "relations":[],
  "lattices":[]
};
</script>

<!-- JavaScript Resource -->
<script src="__app__.js" type="application/ecmascript">
</script>

<!-- Trigger Boot -->
<script type="application/ecmascript">
    bootstrap("./Map.json");
</script>

</body>
</html>
   