<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Flix Standard Library: Set</title>
    <link href="__app__.css" rel="stylesheet" type="text/css"/>
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>

<!-- Application Element -->
<div id="app">
  <div id="navbar"></div>
</div>

<!-- Menu Data -->
<script type="application/ecmascript">
window.menu = [{
  "name":"Prelude",
  "link":"index.html"
},{
  "name":"Int64",
  "link":"Int64.html"
},{
  "name":"Int8",
  "link":"Int8.html"
},{
  "name":"Set",
  "link":"Set.html"
},{
  "name":"Result",
  "link":"Result.html"
},{
  "name":"Float32",
  "link":"Float32.html"
},{
  "name":"Map",
  "link":"Map.html"
},{
  "name":"Float64",
  "link":"Float64.html"
},{
  "name":"Int32",
  "link":"Int32.html"
},{
  "name":"BigInt",
  "link":"BigInt.html"
},{
  "name":"Int16",
  "link":"Int16.html"
},{
  "name":"List",
  "link":"List.html"
},{
  "name":"Option",
  "link":"Option.html"
}];
</script>

<!-- Page Data -->
<script type="application/ecmascript">
window.page = {
  "namespace":"Set",
  "types":[],
  "definitions":[{
    "name":"eq",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    },{
      "name":"ys",
      "tpe":"Set[a]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if `xs` and `ys` and equal, i.e. they have the same elements. "
  },{
    "name":"map",
    "tparams":[{
      "name":"a"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> b"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Set[b]",
    "comment":"  Returns the result of applying `f` to every element in `xs`.  Note: The returned set may be smaller than `xs`. "
  },{
    "name":"flatten",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[Set[a]]"
    }],
    "result":"Set[a]",
    "comment":"  Returns the union of the elements in `xs`. "
  },{
    "name":"difference",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    },{
      "name":"ys",
      "tpe":"Set[a]"
    }],
    "result":"Set[a]",
    "comment":"  Returns the difference of `xs` and `ys`, i.e. `xs - ys`. "
  },{
    "name":"flatMap",
    "tparams":[{
      "name":"a"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Set[b]"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Set[b]",
    "comment":"  Returns the result of applying `f` to every element in `xs` and taking the union. "
  },{
    "name":"reduceRight",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> a -> a"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Option[a]",
    "comment":"  Applies `f` to all elements in `xs` going from right to left until a single value `v` is obtained.  Returns `Some(v)`.  That is, the result is of the form: `Some(f(x1, ...f(xn-2, f(xn-1, xn))...))`  Returns `None` if `xs` is the empty set. "
  },{
    "name":"empty",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[],
    "result":"Set['7190]",
    "comment":"  Returns the empty set.  `#{}` is syntactic sugar for `empty` (`#{} = empty()`). "
  },{
    "name":"singleton",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"x",
      "tpe":"a"
    }],
    "result":"Set[a]",
    "comment":"  Returns the singleton set containing `x`.  `#{x}` is syntactic sugar for `singleton` (`#{x} = singleton(x)`). "
  },{
    "name":"fold",
    "tparams":[{
      "name":"a"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"b -> a -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"b",
    "comment":"  Alias for `foldLeft`. "
  },{
    "name":"isProperSubsetOf",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    },{
      "name":"ys",
      "tpe":"Set[a]"
    }],
    "result":"Bool",
    "comment":"  Returns true if and only if every element in `xs` appears in `ys` and `xs != ys`. "
  },{
    "name":"findRight",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Bool"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Option[a]",
    "comment":"  Optionally returns the first element of `xs` that satisfies the predicate `f` when searching from right to left. "
  },{
    "name":"reduceLeft",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> a -> a"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Option[a]",
    "comment":"  Applies `f` to all elements in `xs` going from left to right until a single value `v` is obtained.  Returns `Some(v)`.  That is, the result is of the form: `Some(f(...f(f(x1, x2), x3)..., xn))`  Returns `None` if `xs` is the empty set. "
  },{
    "name":"union",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    },{
      "name":"ys",
      "tpe":"Set[a]"
    }],
    "result":"Set[a]",
    "comment":"  Returns the union of `xs` and `ys`. "
  },{
    "name":"insert",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"x",
      "tpe":"a"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Set[a]",
    "comment":"  Adds `x` to `xs`. "
  },{
    "name":"partition",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Bool"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"(Set[a], Set[a])",
    "comment":"  Returns a pair of sets `(ys, zs)`.  `ys` contains all elements of `xs` that satisfy the predicate `f`.  `zs` contains all elements of `xs` that do not satisfy the predicate `f`. "
  },{
    "name":"replace",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"x",
      "tpe":"a"
    },{
      "name":"y",
      "tpe":"a"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Set[a]",
    "comment":"  Replaces the element `x` with `y` if `x` is in `xs`.  Otherwise, returns `xs`.  Note: The returned set may be smaller than `xs`. "
  },{
    "name":"size",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Int32",
    "comment":"  Returns the size of `xs`. "
  },{
    "name":"foldRight",
    "tparams":[{
      "name":"a"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> b -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"b",
    "comment":"  Applies `f` to a start value `s` and all elements in `xs` going from right to left.  That is, the result is of the form: `f(x1, ...f(xn-1, f(xn, s))...)`. "
  },{
    "name":"delete",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"x",
      "tpe":"a"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Set[a]",
    "comment":"  Removes `x` from `xs`. "
  },{
    "name":"count",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Bool"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Int32",
    "comment":"  Returns the number of elements in `xs` that satisfy the predicate `f`. "
  },{
    "name":"reduce",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> a -> a"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Option[a]",
    "comment":"  Alias for `reduceLeftOpt`. "
  },{
    "name":"findLeft",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Bool"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Option[a]",
    "comment":"  Optionally returns the first element of `xs` that satisfies the predicate `f` when searching from left to right. "
  },{
    "name":"intersection",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    },{
      "name":"ys",
      "tpe":"Set[a]"
    }],
    "result":"Set[a]",
    "comment":"  Returns the intersection of `xs` and `ys`. "
  },{
    "name":"exists",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Bool"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if at least one element in `xs` satisfies the predicate `f`.  Returns `false` if `xs` is the empty set. "
  },{
    "name":"forall",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Bool"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Bool",
    "comment":"  Returns `true` if and only if all elements in `xs` satisfy the predicate `f`.  Returns `true` if `xs` is the empty set. "
  },{
    "name":"isSubsetOf",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    },{
      "name":"ys",
      "tpe":"Set[a]"
    }],
    "result":"Bool",
    "comment":"  Returns true if and only if every element in `xs` appears in `ys`. "
  },{
    "name":"isEmpty",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Bool",
    "comment":"  Returns true if and only if `xs` is the empty set, i.e. `Set(Nil)`. "
  },{
    "name":"foldLeft",
    "tparams":[{
      "name":"a"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"b -> a -> b"
    },{
      "name":"s",
      "tpe":"b"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"b",
    "comment":"  Applies `f` to a start value `s` and all elements in `xs` going from left to right.  That is, the result is of the form: `f(...f(f(s, x1), x2)..., xn)`. "
  },{
    "name":"memberOf",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"x",
      "tpe":"a"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Bool",
    "comment":"  Returns true if and only if `x` is a member of `xs`. "
  },{
    "name":"find",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Bool"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Option[a]",
    "comment":"  Alias for `findLeft`. "
  },{
    "name":"toList",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"List[a]",
    "comment":"  Returns the set `xs` as a list. "
  },{
    "name":"toMap",
    "tparams":[{
      "name":"a"
    },{
      "name":"b"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[(a, b)]"
    }],
    "result":"Map[a, b]",
    "comment":"  Returns the association set `xs` as a map.  If `xs` contains multiple mappings with the same key, `toMap` does not  make any guarantees about which mapping will be in the resulting map. "
  },{
    "name":"subsets",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Set[Set[a]]",
    "comment":"  Returns all subsets of `xs`. "
  },{
    "name":"filter",
    "tparams":[{
      "name":"a"
    }],
    "fparams":[{
      "name":"f",
      "tpe":"a -> Bool"
    },{
      "name":"xs",
      "tpe":"Set[a]"
    }],
    "result":"Set[a]",
    "comment":"  Returns the set of all elements of `xs` that satisfy the predicate `f`. "
  }],
  "laws":[],
  "tests":[],
  "relations":[],
  "lattices":[]
};
</script>

<!-- JavaScript Resource -->
<script src="__app__.js" type="application/ecmascript">
</script>

<!-- Trigger Boot -->
<script type="application/ecmascript">
    bootstrap("./Set.json");
</script>

</body>
</html>
   